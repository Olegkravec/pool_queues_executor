# Pool Queues Executor
## Коротко об разработке
Pool Queues Executor - является неким highload балансером пользовательских задач. Все задачи групируются по пуллам, которые могут быть идентифицированы любым непримитивным типом.
## Примеры
Обявление самого раннера(все параметры описаны ниже):
```aidl
    private static ThreadPoolsRunner<Integer> PoolsExecutor = new ThreadPoolsRunner<>(RUN_POLICY.RUN_EXECUTOR, THREAD_POLICY.TOTAL_LIMIT, 1000, 10);
```

Создание первого пулла, и передача нашей callback функции:
```aidl
PoolsExecutor.newPool(1, () -> System.out.println("My custom pool done!"));
```

Создание первой задачи и добавление етой задачи в только что созданый пулл:
```aidl
PoolsExecutor.poolAddThread(1, new ThreadCommand<String>(" for pool:" + u) {
                @Override
                public void run() {
                    Random rand = new Random();
                    int random = rand.nextInt(10) + 1;
                    System.out.println("Running thread num: " + object + "\t"+Thread.currentThread().getId());
                    try {
                        Thread.sleep(random);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            });
```

Так как мы установили RUN_POLICY как RUN_EXECUTOR, весь наш пул запускается только по нашей команде, вот так:
```aidl
PoolsExecutor.executeAll();
```
## Параметры
### Обявление
#### Крос-типизация пулов
При создании раннера Вы вправе обявить тип данных как ключ(идентификатор) пулов, например, я в примере обявил что мои пулы просто нумеруются - тип Integer
```aidl
    ...ThreadPoolsRunner<Integer> PoolsExecutor...
```
Но я хочу чтобы был один пул на одного пользователя моей платформы, тогда просто:
```aidl
    ...ThreadPoolsRunner<ClientModel> PoolsExecutor...
```
#### Параметры запуска
Итак, немного об ***RUN_POLICY***, на данный момент есть три типа запуска пулов:
* ***RUN_EXECUTOR*** - когда вы создаете пуллы, добвляете свои команды, и допустим через несколько минут хотите их запустить, тоесть запуск пуллов по команде ***executeAll()***. 
* ***RUN_ONADD*** - старт всех задач в момент вызова метода ***poolExecute(queueType poolID)***. Создаете пул, начинаете добавлять задачу, и вызвите метод для старта пула.  (Устаревший тип)
* ***RUN_PRESTART*** - запуск всех задач в момент их регистрации в любом пулле.

Но какая же система была-бы устойчивая если бы небыло лимиов, которые реализовани в pool_queues_executor - ***THREAD_POLICY***:
* ***TOTAL_LIMIT*** - лимит запущеных задач в любых пулах, тоесть если TOTAL_LIMIT вы ставите как 10, то на два пула будет использовано по 5 потоков, как только новый пул будет создан, TOTAL_LIMIT будет пересчитан для всех пуллов, и будет еже не по 5 потоков, а по 3. И как только идин пулл будет выполен, количество запускаемых потоков для каждого пула, будет вновь пересчитано.
* ***POOL_LIMIT*** - лимитирование запущеных задачь только внутри одного потока. Например, если вы POOL_LIMIT ставите как 10, то независимо сколько создано самых пулов, для каждого пулла будет запущено по 10 потоков одновременно.

В pool_queues_executor также реализована ***система мониторинга*** за всеми пулами, в случае если будет непредвиденная критическая ошибка, или зависание, или поток перейдет в sleep режим по какой-то причине - система мониторинга будет автоматически исправлять такие задачи. Параметер MonitorRecheckTime позволяет задать время перепроверки каждого пула. MonitorRecheckTime ставиться в зависимости от мощности сервера и ожидаемого количесва пулов. В идеале - чем меньше будет стоять это значение, тем меньша будет задержка от момента завершения всех задач в пулле, до вызова callback функции.
### Создание пула
Параметрами метода ***newPool()*** есть:
* ***queueType poolID*** - инициализированый объект, обявленного ранее типа данных(В моем случае Integer) 
* ***ThreadPoolCallBacks callBacks*** - callback обект, вызываемый в момент, еквивалентный назве его внутреннего метода. 
### Добавление потоков
Для ***poolAddThread()*** нужно передать такие параметры:
* ***queueType poolID*** - идентификатор пула, куда добавлять задачу. Ранее создан методом ***newPool()*** 
* ***ThreadCommand сommand*** - екземпляр задачи, наследованой от ***Runnable*** класса. Может содержать собственный контекст задачи, например, в примере выше я передавал в задачу контекст типа String, но можно передать любое нужное вам значение, предварительно указав тип данных:
```aidl
PoolsExecutor.poolAddThread(1, new ThreadCommand<ClientModel>(myClientModelObject) {
            @Override
            public void run() {
                System.out.println("Client name: " + object.getName());
            }
        });
```
Или:

```aidl
PoolsExecutor.poolAddThread(1, new ThreadCommand<Void>(null) {
            @Override
            public void run() {
                // My code without context.
            }
        });
```
Контекст самой задачи хранится в свойстве ***object*** и является public свойством, может быть любого ***непримитивного типа***.


